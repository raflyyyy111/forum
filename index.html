<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Chat [v4 - Stabilized]</title>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <style>
        :root {
            --bg-color: #0D0D0D;
            --text-color: #00FF41;
            --accent-color: #33FF77;
            --meta-color: #888888;
            --error-color: #FF4136;
            --font-family: 'Consolas', 'Menlo', 'Courier New', monospace;
        }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            margin: 0;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }
        #chat-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            border: 1px solid var(--accent-color);
            padding: 1rem;
        }
        #messages {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 1rem;
            word-wrap: break-word;
        }
        .message { margin-bottom: 0.5rem; }
        .message .sender { font-weight: bold; color: var(--accent-color); }
        .message.system .content { color: var(--meta-color); font-style: italic; }
        .message.error .content { color: var(--error-color); font-style: italic; }
        #input-container { display: flex; }
        #chat-input {
            flex-grow: 1;
            background-color: transparent;
            border: none;
            border-bottom: 1px solid var(--accent-color);
            color: var(--text-color);
            font-family: var(--font-family);
            font-size: 1rem;
            padding: 0.5rem;
            outline: none;
        }
        #chat-input:focus { border-bottom-color: var(--text-color); }
        #send-button {
            background-color: var(--accent-color);
            color: var(--bg-color);
            border: none;
            padding: 0.5rem 1rem;
            margin-left: 1rem;
            cursor: pointer;
            font-family: var(--font-family);
            font-weight: bold;
        }
        #initial-screen { text-align: center; padding-top: 20vh; }
        .hidden { display: none; }
    </style>
</head>
<body>

    <div id="initial-screen">
        <h1>Welcome to Anonymous P2P Chat</h1>
        <p>To start or join a chat room, add a name to the URL hash.</p>
        <p>Example: <strong>your-url.com/#my-secret-room</strong></p>
    </div>

    <div id="chat-container" class="hidden">
        <div id="messages"></div>
        <div id="input-container">
            <input type="text" id="chat-input" placeholder="Type message and press Enter...">
            <button id="send-button">SEND</button>
        </div>
    </div>

    <script>
        const roomName = window.location.hash.substring(1);
        const initialScreen = document.getElementById('initial-screen');
        const chatContainer = document.getElementById('chat-container');

        if (!roomName) {
            chatContainer.classList.add('hidden');
            initialScreen.classList.remove('hidden');
        } else {
            initialScreen.classList.add('hidden');
            chatContainer.classList.remove('hidden');
            initializeChat();
        }

        function initializeChat() {
            const messagesDiv = document.getElementById('messages');
            const chatInput = document.getElementById('chat-input');
            const sendButton = document.getElementById('send-button');

            const MQTT_BROKER = 'wss://broker.hivemq.com:8884/mqtt';
            const MQTT_TOPIC_PREFIX = 'webrtc-p2p-chat-app-v4-stable/';
            const MQTT_TOPIC = MQTT_TOPIC_PREFIX + roomName;
            const STUN_SERVERS = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

            const myPeerId = 'peer_' + Math.random().toString(36).substr(2, 9);
            const myUsername = 'User-' + Math.random().toString(36).substr(2, 4).toUpperCase();
            const peers = {}; // State: { pc, dc, iceQueue }
            let mqttClient = null;

            const addMessage = (text, sender = "System", type = "system") => {
                const msgDiv = document.createElement('div');
                msgDiv.className = `message ${type}`;
                const senderSpan = sender ? `<span class="sender">${sender}: </span>` : '';
                msgDiv.innerHTML = `${senderSpan}<span class="content">${text}</span>`;
                messagesDiv.appendChild(msgDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            };

            const connectToSignaling = () => {
                addMessage(`Connecting to signaling network...`);
                const will = {
                    topic: MQTT_TOPIC,
                    payload: JSON.stringify({ sender: myPeerId, type: 'leave' }),
                    qos: 1,
                    retain: false
                };
                mqttClient = mqtt.connect(MQTT_BROKER, { will });

                mqttClient.on('connect', () => {
                    addMessage(`Connected! Joining room: #${roomName}`);
                    mqttClient.subscribe(MQTT_TOPIC, (err) => {
                        if (!err) {
                            const payload = { sender: myPeerId, type: 'join' };
                            mqttClient.publish(MQTT_TOPIC, JSON.stringify(payload));
                            addMessage(`You joined as ${myUsername}. Waiting for peers...`);
                        }
                    });
                });

                mqttClient.on('message', (topic, message) => {
                    try {
                        const data = JSON.parse(message.toString());
                        if (data.sender === myPeerId) return;
                        handleSignalingData(data);
                    } catch (e) { console.error('Malformed signal:', e); }
                });

                mqttClient.on('error', (err) => addMessage(`Signaling error: ${err.message}. Please refresh.`, "System", "error"));
            };

            const handleSignalingData = async (data) => {
                const peerId = data.sender;
                switch (data.type) {
                    case 'join':
                        if (myPeerId > peerId) {
                            addMessage(`Peer ${peerId.substr(5, 4)} detected. Initiating connection...`);
                            createPeerConnection(peerId, true);
                        }
                        break;
                    case 'offer':
                        addMessage(`Receiving connection offer from ${peerId.substr(5, 4)}...`);
                        await createPeerConnection(peerId, false, data.offer);
                        break;
                    case 'answer':
                        if (peers[peerId]) {
                           await peers[peerId].pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                        }
                        break;
                    case 'candidate':
                        if (peers[peerId]) {
                            await peers[peerId].pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                        }
                        break;
                    case 'leave':
                        if (peers[peerId]) {
                            addMessage(`Peer ${peerId.substr(5, 4)} has left.`);
                            peers[peerId].pc.close();
                            delete peers[peerId];
                        }
                        break;
                }
            };
            
            const createPeerConnection = async (peerId, isInitiator, offer = null) => {
                if (peers[peerId]) return;

                const pc = new RTCPeerConnection(STUN_SERVERS);
                peers[peerId] = { pc: pc, dc: null };

                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        sendSignal({ type: 'candidate', candidate: event.candidate, target: peerId });
                    }
                };
                
                pc.onconnectionstatechange = () => {
                    if (pc.connectionState === 'failed') {
                        addMessage(`Connection with ${peerId.substr(5, 4)} failed.`, "System", "error");
                        pc.close();
                        delete peers[peerId];
                    }
                };

                const setupDataChannel = (dc) => {
                    peers[peerId].dc = dc;
                    dc.onopen = () => addMessage(`âœ… Secure P2P connection established with ${peerId.substr(5, 4)}.`);
                    dc.onmessage = (event) => {
                        const msg = JSON.parse(event.data);
                        addMessage(msg.text, msg.username, 'user');
                    };
                    dc.onclose = () => {
                        // This event is often handled by 'leave' signal, but good as a fallback.
                        if (peers[peerId]) {
                           addMessage(`Connection with ${peerId.substr(5, 4)} closed.`);
                           delete peers[peerId];
                        }
                    };
                };

                if (isInitiator) {
                    const dc = pc.createDataChannel('chat');
                    setupDataChannel(dc);
                    const newOffer = await pc.createOffer();
                    await pc.setLocalDescription(newOffer);
                    sendSignal({ type: 'offer', offer: pc.localDescription, target: peerId });
                } else { // Is Receiver
                    pc.ondatachannel = (event) => {
                        setupDataChannel(event.channel);
                    };
                    await pc.setRemoteDescription(new RTCSessionDescription(offer));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    sendSignal({ type: 'answer', answer: pc.localDescription, target: peerId });
                }
            };

            const sendSignal = (data) => {
                const payload = { sender: myPeerId, ...data };
                mqttClient.publish(MQTT_TOPIC, JSON.stringify(payload));
            };

            const broadcastMessage = (text) => {
                addMessage(text, myUsername, 'user');
                const message = { username: myUsername, text: text };
                const payload = JSON.stringify(message);
                Object.values(peers).forEach(peer => {
                    if (peer.dc && peer.dc.readyState === 'open') {
                        peer.dc.send(payload);
                    }
                });
            };
            
            sendButton.addEventListener('click', () => {
                const text = chatInput.value;
                if (text) {
                    broadcastMessage(text);
                    chatInput.value = '';
                }
            });

            chatInput.addEventListener('keydown', (e) => (e.key === 'Enter') && (e.preventDefault(), sendButton.click()));

            // Mulai semuanya
            connectToSignaling();
        }
    </script>
</body>
</html>
