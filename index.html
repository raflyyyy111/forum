<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Chat [v6 - Final]</title>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <style>
        :root {
            --bg-color: #0D0D0D;
            --text-color: #00FF41;
            --accent-color: #33FF77;
            --meta-color: #888888;
            --error-color: #FF4136;
            --font-family: 'Consolas', 'Menlo', 'Courier New', monospace;
        }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            margin: 0;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }
        #chat-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            border: 1px solid var(--accent-color);
            padding: 1rem;
        }
        #messages {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 1rem;
            word-wrap: break-word;
        }
        .message { margin-bottom: 0.5rem; }
        .message .sender { font-weight: bold; color: var(--accent-color); }
        .message.system .content { color: var(--meta-color); font-style: italic; }
        .message.error .content { color: var(--error-color); font-style: italic; }
        #input-container { display: flex; }
        #chat-input {
            flex-grow: 1;
            background-color: transparent;
            border: none;
            border-bottom: 1px solid var(--accent-color);
            color: var(--text-color);
            font-family: var(--font-family);
            font-size: 1rem;
            padding: 0.5rem;
            outline: none;
        }
        #chat-input:focus { border-bottom-color: var(--text-color); }
        #send-button {
            background-color: var(--accent-color);
            color: var(--bg-color);
            border: none;
            padding: 0.5rem 1rem;
            margin-left: 1rem;
            cursor: pointer;
            font-family: var(--font-family);
            font-weight: bold;
        }
        #initial-screen { text-align: center; padding-top: 20vh; }
        .hidden { display: none; }
    </style>
</head>
<body>

    <div id="initial-screen">
        <h1>Welcome to Anonymous P2P Chat</h1>
        <p>To start or join a chat room, add a name to the URL hash.</p>
        <p>Example: <strong>your-url.com/#my-secret-room</strong></p>
    </div>

    <div id="chat-container" class="hidden">
        <div id="messages"></div>
        <div id="input-container">
            <input type="text" id="chat-input" placeholder="Type message and press Enter...">
            <button id="send-button">SEND</button>
        </div>
    </div>

    <script>
        const roomName = window.location.hash.substring(1);
        const initialScreen = document.getElementById('initial-screen');
        const chatContainer = document.getElementById('chat-container');

        if (!roomName) {
            chatContainer.classList.add('hidden');
            initialScreen.classList.remove('hidden');
        } else {
            initialScreen.classList.add('hidden');
            chatContainer.classList.remove('hidden');
            initializeChat();
        }

        function initializeChat() {
            const messagesDiv = document.getElementById('messages');
            const chatInput = document.getElementById('chat-input');
            const sendButton = document.getElementById('send-button');

            const MQTT_BROKER = 'wss://broker.hivemq.com:8884/mqtt';
            // Topic unik untuk memastikan tidak ada tabrakan antar versi
            const MQTT_TOPIC_PREFIX = 'webrtc-p2p-chat-app-v6-final/';
            const MQTT_TOPIC = MQTT_TOPIC_PREFIX + roomName;
            const STUN_SERVERS = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

            const myPeerId = 'peer_' + Math.random().toString(36).substr(2, 9);
            const myUsername = 'User-' + Math.random().toString(36).substr(2, 4).toUpperCase();
            const peers = {};
            let mqttClient = null;

            const addMessage = (text, sender = "System", type = "system") => {
                const msgDiv = document.createElement('div');
                msgDiv.className = `message ${type}`;
                const senderSpan = sender ? `<span class="sender">${sender}: </span>` : '';
                msgDiv.innerHTML = `${senderSpan}<span class="content">${text}</span>`;
                messagesDiv.appendChild(msgDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            };

            const cleanupPeer = (peerId) => {
                if (peers[peerId]) {
                    peers[peerId].pc.close();
                    delete peers[peerId];
                }
            };

            const connectToSignaling = () => {
                addMessage(`Connecting to signaling network...`);
                // Last Will and Testament: Jika koneksi terputus tiba-tiba, kirim sinyal 'leave'
                const will = {
                    topic: MQTT_TOPIC,
                    payload: JSON.stringify({ sender: myPeerId, type: 'leave' }),
                    qos: 1,
                    retain: false
                };
                mqttClient = mqtt.connect(MQTT_BROKER, { will });

                mqttClient.on('connect', () => {
                    addMessage(`Connected! Joining room: #${roomName}`);
                    mqttClient.subscribe(MQTT_TOPIC, (err) => {
                        if (!err) {
                            // Kirim sinyal join yang akan disimpan oleh broker (retain: true)
                            const payload = { sender: myPeerId, type: 'join', username: myUsername };
                            mqttClient.publish(MQTT_TOPIC, JSON.stringify(payload), { retain: true });
                            addMessage(`You joined as ${myUsername}. Establishing connections...`);
                        }
                    });
                });

                mqttClient.on('message', (topic, message) => {
                    try {
                        const data = JSON.parse(message.toString());
                        // Abaikan pesan dari diri sendiri
                        if (data.sender === myPeerId) return;
                        handleSignalingData(data);
                    } catch (e) { /* Abaikan pesan yang rusak */ }
                });

                mqttClient.on('error', (err) => addMessage(`Signaling error: ${err.message}`, "System", "error"));
            };

            const handleSignalingData = async (data) => {
                const peerId = data.sender;
                switch (data.type) {
                    case 'join':
                        if (peers[peerId]) return; // Jika koneksi sudah ada, abaikan
                        addMessage(`Peer '${data.username}' (${peerId.substr(5, 4)}) detected.`);
                        // Hanya peer dengan ID lebih besar (secara abjad) yang memulai koneksi untuk mencegah konflik
                        if (myPeerId > peerId) {
                            addMessage(`Initiating connection to ${data.username}...`);
                            await createPeerConnection(peerId, true);
                        }
                        break;
                    case 'offer':
                        await createPeerConnection(peerId, false, data.offer);
                        break;
                    case 'answer':
                        if (peers[peerId]) {
                           await peers[peerId].pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                        }
                        break;
                    case 'candidate':
                        if (peers[peerId] && peers[peerId].pc.remoteDescription) {
                            await peers[peerId].pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                        }
                        break;
                    case 'leave':
                        if (peers[peerId]) {
                            addMessage(`Peer '${peers[peerId].username || peerId.substr(5, 4)}' has left.`);
                            cleanupPeer(peerId);
                        }
                        break;
                }
            };
            
            const createPeerConnection = async (peerId, isInitiator, offer = null) => {
                // **FIX PENTING**: Mencegah koneksi ke diri sendiri atau duplikat
                if (peerId === myPeerId || peers[peerId]) return;

                const pc = new RTCPeerConnection(STUN_SERVERS);
                peers[peerId] = { pc: pc, dc: null, username: 'Unknown' };

                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        sendSignal({ type: 'candidate', candidate: event.candidate, target: peerId });
                    }
                };
                
                pc.onconnectionstatechange = () => {
                    if (['failed', 'disconnected', 'closed'].includes(pc.connectionState)) {
                        if (peers[peerId]) {
                           addMessage(`Connection with ${peers[peerId].username} lost.`, "System", "error");
                           cleanupPeer(peerId);
                        }
                    }
                };

                const setupDataChannel = (dc) => {
                    peers[peerId].dc = dc;
                    dc.onopen = () => {
                        addMessage(`âœ… Secure P2P connection established with ${peers[peerId].username}.`);
                    };
                    dc.onmessage = (event) => {
                        const msg = JSON.parse(event.data);
                        peers[msg.sender].username = msg.username; // Update username jika berubah
                        addMessage(msg.text, msg.username, 'user');
                    };
                };

                if (isInitiator) {
                    const dc = pc.createDataChannel('chat');
                    setupDataChannel(dc);
                    const newOffer = await pc.createOffer();
                    await pc.setLocalDescription(newOffer);
                    sendSignal({ type: 'offer', offer: pc.localDescription, target: peerId });
                } else { // Is Receiver
                    pc.ondatachannel = (event) => setupDataChannel(event.channel);
                    await pc.setRemoteDescription(new RTCSessionDescription(offer));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    sendSignal({ type: 'answer', answer: pc.localDescription, target: peerId });
                }
            };

            const sendSignal = (data) => {
                const payload = { sender: myPeerId, ...data };
                mqttClient.publish(MQTT_TOPIC, JSON.stringify(payload));
            };

            const broadcastMessage = (text) => {
                addMessage(text, myUsername, 'user');
                const message = { sender: myPeerId, username: myUsername, text: text };
                const payload = JSON.stringify(message);
                Object.values(peers).forEach(peer => {
                    if (peer.dc && peer.dc.readyState === 'open') {
                        peer.dc.send(payload);
                    }
                });
            };
            
            // Fungsi untuk membersihkan 'retained message' saat tab ditutup
            window.addEventListener('beforeunload', (event) => {
                if (mqttClient && mqttClient.connected) {
                    // Kirim payload kosong dengan retain: true untuk menghapus pesan 'join' dari broker
                    mqttClient.publish(MQTT_TOPIC, JSON.stringify({ sender: myPeerId, type: 'leave' }), { retain: false });
                    const clearPayload = "";
                    mqttClient.publish(MQTT_TOPIC, clearPayload, { retain: true });
                }
            });

            sendButton.addEventListener('click', () => {
                const text = chatInput.value;
                if (text) {
                    broadcastMessage(text);
                    chatInput.value = '';
                }
            });

            chatInput.addEventListener('keydown', (e) => (e.key === 'Enter') && (e.preventDefault(), sendButton.click()));

            connectToSignaling();
        }
    </script>
</body>
</html>
